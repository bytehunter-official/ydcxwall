<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <link rel="icon" type="image/x-icon" href="img/logo.ico"/>
    <title>ZY知识库-便签墙</title>
    <style>
        :root {
            /* 过渡动画 */
            --transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            --transition-fast: all 0.2s ease;
            --transition-slow: all 0.5s ease;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background-image: linear-gradient(0deg, #eee 1px, transparent 0),
            linear-gradient(90deg, #eee 1px, transparent 0);
            background-size: 30px 30px;
            color: #333;
            min-height: 100dvh;
            overflow: hidden;
        }

        body.is-mobile {
            overflow-y: auto;
        }

        #board {
            position: relative;
            width: 100vw;
            height: 100dvh;
            overflow: hidden;
        }

        body.is-mobile #board {
            height: auto;
            min-height: 100dvh;
        }

        .card {
            position: absolute;
            width: 220px;
            border-radius: 12px;
            box-shadow: 0 16px 35px rgba(0, 0, 0, 0.2);
            background: #fff;
            border: 1px solid rgba(0, 0, 0, 0.08);
            overflow: hidden;
            transform-origin: center;
            transition: transform 0.35s ease, opacity 0.35s ease, left 0.35s ease,
            top 0.35s ease, width 0.35s ease, height 0.35s ease,
            border-radius 0.35s ease;
        }

        .card.dragging {
            transition: none;
            box-shadow: 0 22px 45px rgba(0, 0, 0, 0.35);
        }

        .card.maximized {
            box-shadow: 0 28px 60px rgba(0, 0, 0, 0.4);
        }

        .card-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            background: rgba(255, 255, 255, 0.7);
            cursor: grab;
            user-select: none;
            touch-action: pan-y;
        }

        .card-header.dragging {
            cursor: grabbing;
        }

        .window-controls {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .window-controls .control {
            position: relative;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 1px solid rgba(0, 0, 0, 0.08);
            background: #ccc;
            cursor: pointer;
            outline: none;
            padding: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .window-controls .control.close {
            background: #ff5f57;
            border-color: #e0443e;
        }

        .window-controls .control.minimize {
            background: #febb2e;
            border-color: #dea123;
        }

        .window-controls .control.maximize {
            background: #28c840;
            border-color: #1aab2c;
        }

        .window-controls .control::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .card-header:hover .window-controls .control::after {
            opacity: 0.8;
        }

        .window-controls .control.close::after {
            content: '×';
            width: auto;
            height: auto;
            background: none;
            font-size: 10px;
            line-height: 1;
            font-weight: 700;
            color: rgba(0, 0, 0, 0.7);
        }

        .window-controls .control.minimize::after {
            width: 6px;
            height: 2px;
            background: rgba(0, 0, 0, 0.6);
        }

        .window-controls .control.maximize::after {
            width: 6px;
            height: 6px;
            background: linear-gradient(
                    45deg,
                    rgba(0, 0, 0, 0.6) 0%,
                    rgba(0, 0, 0, 0.6) 45%,
                    transparent 45%,
                    transparent 55%,
                    rgba(0, 0, 0, 0.6) 55%,
                    rgba(0, 0, 0, 0.6) 100%
            );
        }

        .card-title {
            font-size: 13px;
            font-weight: 600;
            color: rgba(0, 0, 0, 0.55);
            padding-left: 10px;
            flex: 1;
        }

        .card-body {
            padding: 16px;
            font-size: 16px;
            line-height: 1.4;
            font-weight: 600;
            color: rgba(0, 0, 0, 0.72);
        }

        @media (max-width: 768px) {
            .card {
                width: 180px;
                border-radius: 10px;
            }

            .card-body {
                padding: 14px;
                font-size: 14px;
            }

            .card-title {
                font-size: 12px;
            }
        }

        .github-corner {
            position: fixed;
            top: 0;
            left: 0;
            border: 0;
            transform: scaleX(-1);
            z-index: 1000;
        }

        .github-corner:hover svg {
            fill: var(--primary-dark);
        }

        .github-corner svg {
            fill: var(--primary-color);
            color: white;
            transition: var(--transition);
        }

        .github-corner:hover .octo-arm {
            animation: octocat-wave 560ms ease-in-out;
        }

        @keyframes octocat-wave {
            0%, 100% {
                transform: rotate(0);
            }
            20%, 60% {
                transform: rotate(-25deg);
            }
            40%, 80% {
                transform: rotate(10deg);
            }
        }

        #note-input-container {
            position: fixed;
            left: 50%;
            bottom: 40px;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            align-items: center;
            background: rgba(255, 255, 255, 0.3); /* 半透明背景 */
            backdrop-filter: blur(10px); /* 毛玻璃效果 */
            padding: 10px 16px;
            border-radius: 16px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            z-index: 1000001;
            transition: all 0.3s ease;
        }

        #note-input {
            flex: 1;
            font-size: 16px;
            padding: 10px 14px;
            border: 1px solid rgba(255, 255, 255, 0.5);
            border-radius: 12px;
            outline: none;
            background: rgba(255, 255, 255, 0.25); /* 半透明输入背景 */
            color: #333;
            min-width: 280px;
            box-shadow: inset 0 2px 4px rgba(255, 255, 255, 0.3);
            transition: all 0.2s ease;
        }

        #note-input::placeholder {
            color: rgba(0, 0, 0, 0.4);
        }

        #note-input:focus {
            background: rgba(255, 255, 255, 0.5);
            border-color: rgba(0, 0, 0, 0.2);
        }

        #note-submit {
            font-size: 16px;
            padding: 10px 18px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            background: rgba(76, 175, 80, 0.7); /* 半透明绿色 */
            color: white;
            backdrop-filter: blur(6px);
            transition: all 0.25s ease;
            box-shadow: 0 2px 6px rgba(76, 175, 80, 0.3);
        }

        #note-submit:hover {
            background: rgba(76, 175, 80, 0.9);
            transform: translateY(-1px);
            box-shadow: 0 4px 10px rgba(76, 175, 80, 0.4);
        }

        #note-submit:active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(76, 175, 80, 0.3);
        }

        #top-link-container {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000002;
        }

        #top-link-container .top-link-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 10px 20px;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.35);
            color: rgba(0, 0, 0, 0.72);
            font-size: 16px;
            font-weight: 600;
            text-decoration: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
            backdrop-filter: blur(10px);
            transition: all 0.25s ease;
        }

        #top-link-container .top-link-button .top-link-icon {
            width: 18px;
            height: 18px;
            margin-right: 8px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            fill: rgba(76, 175, 80, 0.8);
            transition: transform 0.25s ease, fill 0.25s ease;
        }

        #top-link-container .top-link-button:hover {
            background: rgba(255, 255, 255, 0.55);
            transform: translateY(-2px);
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.18);
        }

        #top-link-container .top-link-button:hover .top-link-icon {
            transform: scale(1.1);
            fill: rgba(76, 175, 80, 1);
        }

        #top-link-container .top-link-button:active {
            transform: translateY(0);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.15);
        }
    </style>
</head>
<body>
<!-- GitHub 角标 -->
<a href="https://github.com/ZyPLJ/NoteWeb" target="_blank" aria-label="View source on Github"
   class="github-corner">
    <svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true" style="fill: #151513; color: #fff;">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path
                d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
                fill="currentColor" class="octo-arm" style="transform-origin: 130px 106px;"></path>
        <path
                d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
                fill="currentColor" class="octo-body"></path>
    </svg>
</a>
<div id="top-link-container">
    <a class="top-link-button" href="/wordcloud.png" target="_blank" rel="noopener noreferrer">
        <svg class="top-link-icon" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
            <path d="M5 5h7v2H7v10h10v-5h2v7a1 1 0 0 1-1 1H6a1 1 0 0 1-1-1V6a1 1 0 0 1 1-1Zm11-2h5v5h-2V5.414l-6.793 6.793-1.414-1.414L17.586 4H16V3Z"></path>
        </svg>
        词云图
    </a>
</div>
<div id="board"></div>
<!-- 添加便签输入区域 -->
<div id="note-input-container">
    <input id="note-input" type="text" placeholder="输入新的便签内容..."/>
    <button id="note-submit">添加</button>
</div>

<script>
    const board = document.getElementById('board')

    const colors = [
        '#ffe0e3',
        '#c7f0ff',
        '#ffd8a8',
        '#d9f2d9',
        '#e5d7ff',
        '#f9f7d9',
        '#d2f0f8',
        '#ffd4f5'
    ]

    const cardStates = new WeakMap()
    const MAXIMIZED_LAYER = 1000000
    let activeMaximizedCard = null
    let isMobile =
        window.matchMedia('(pointer: coarse)').matches ||
        window.innerWidth <= 768
    let zIndexCursor = 200

    document.body.classList.toggle('is-mobile', isMobile)

    function randomFrom(array) {
        return array[Math.floor(Math.random() * array.length)]
    }

    function clamp(value, min, max) {
        return Math.min(Math.max(value, min), max)
    }

    function applyTransform(card, state) {
        const scale = state.scale ?? 1
        const translateX = state.translateX ?? 0
        const translateY = state.translateY ?? 0
        const angle = state.angle ?? 0
        card.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale}) rotate(${angle}deg)`
    }

    function bringToFront(card) {
        if (card === activeMaximizedCard) {
            card.style.zIndex = MAXIMIZED_LAYER
            return
        }

        zIndexCursor += 1
        if (activeMaximizedCard && zIndexCursor >= MAXIMIZED_LAYER) {
            zIndexCursor = MAXIMIZED_LAYER - 1
        }

        card.style.zIndex = zIndexCursor
    }

    function setupCardInteractions(card) {
        const header = card.querySelector('.card-header')
        const closeBtn = card.querySelector('.control.close')
        const minimizeBtn = card.querySelector('.control.minimize')
        const maximizeBtn = card.querySelector('.control.maximize')

        closeBtn.addEventListener('click', event => {
            event.stopPropagation()
            closeCard(card)
        })

        minimizeBtn.addEventListener('click', event => {
            event.stopPropagation()
            minimizeCard(card)
        })

        maximizeBtn.addEventListener('click', event => {
            event.stopPropagation()
            toggleMaximize(card)
        })

        header.addEventListener('pointerdown', event => {
            if (event.pointerType === 'touch') return
            startDrag(event, card)
        })

        card.addEventListener('pointerdown', () => {
            bringToFront(card)
        })

        header.addEventListener('dblclick', event => {
            if (!event.target.closest('.control')) {
                toggleMaximize(card)
            }
        })
    }

    function closeCard(card) {
        const state = cardStates.get(card)
        if (!state || state.closing) return
        if (card === activeMaximizedCard) {
            activeMaximizedCard = null
        }
        state.closing = true
        state.scale = 0.1
        card.style.opacity = '0'
        applyTransform(card, state)

        const handleTransitionEnd = event => {
            if (event.propertyName === 'opacity') {
                card.removeEventListener('transitionend', handleTransitionEnd)
                card.remove()
            }
        }

        card.addEventListener('transitionend', handleTransitionEnd)
    }

    function minimizeCard(card) {
        const state = cardStates.get(card)
        if (!state || state.closing) return

        const runMinimize = () => {
            state.closing = true
            bringToFront(card)
            const bottom = Math.max(window.innerHeight - 24, 0)
            const targetLeft = clamp(
                state.left,
                16,
                Math.max(window.innerWidth - card.offsetWidth - 16, 16)
            )

            state.left = targetLeft
            state.top = bottom
            state.scale = 0.1
            state.angle = 0
            card.style.left = `${targetLeft}px`
            card.style.top = `${bottom}px`
            card.style.opacity = '0.35'
            applyTransform(card, state)

            const handleTransitionEnd = event => {
                if (event.propertyName === 'transform') {
                    card.removeEventListener('transitionend', handleTransitionEnd)
                    card.remove()
                }
            }

            card.addEventListener('transitionend', handleTransitionEnd)
        }

        if (state.maximized) {
            activeMaximizedCard = null
            state.maximized = false
            card.classList.remove('maximized')
            card.style.borderRadius = '12px'
            state.left = 0
            state.top = 0
            state.scale = 1
            state.angle = 0
            applyTransform(card, state)

            requestAnimationFrame(() => {
                requestAnimationFrame(runMinimize)
            })
            return
        }

        runMinimize()
    }

    function toggleMaximize(card) {
        const state = cardStates.get(card)
        if (!state || state.closing) return

        if (state.maximized) {
            restoreFromMaximize(card, state)
        } else {
            maximizeCard(card, state)
        }
    }

    function maximizeCard(card, state) {
        state.beforeMaximize = {
            left: state.left,
            top: state.top,
            scale: state.scale ?? 1,
            width: card.offsetWidth,
            height: card.offsetHeight,
            angle: state.angle ?? 0
        }

        card.classList.add('maximized')
        card.style.left = '0px'
        card.style.top = '0px'
        card.style.width = `${window.innerWidth}px`
        card.style.height = `${window.innerHeight}px`
        card.style.borderRadius = '0'

        state.left = 0
        state.top = 0
        state.scale = 1
        state.angle = 0
        applyTransform(card, state)
        activeMaximizedCard = card
        bringToFront(card)
        state.maximized = true
    }

    function restoreFromMaximize(card, state) {
        const previous = state.beforeMaximize
        if (!previous) return

        card.classList.remove('maximized')
        card.style.left = `${previous.left}px`
        card.style.top = `${previous.top}px`
        card.style.width = `${previous.width}px`
        card.style.height = `${previous.height}px`
        card.style.borderRadius = '12px'

        state.left = previous.left
        state.top = previous.top
        state.scale = previous.scale ?? 1
        state.angle = previous.angle ?? state.angle ?? 0
        applyTransform(card, state)
        state.maximized = false
        if (activeMaximizedCard === card) {
            activeMaximizedCard = null
        }
        bringToFront(card)
        state.lastPosition = {left: state.left, top: state.top}

        setTimeout(() => {
            if (!state.maximized) {
                card.style.width = ''
                card.style.height = ''
                state.width = card.offsetWidth
                state.height = card.offsetHeight
            }
        }, 360)
    }

    function startDrag(event, card) {
        const control = event.target.closest('.control')
        if (control) return

        const state = cardStates.get(card)
        if (!state || state.closing || state.maximized) return

        event.preventDefault()
        bringToFront(card)

        const header = card.querySelector('.card-header')
        card.classList.add('dragging')
        header.classList.add('dragging')

        state.dragging = true
        state.dragOffsetX = event.clientX - state.left
        state.dragOffsetY = event.clientY - state.top

        let dragFrame = null
        let pendingLeft = state.left
        let pendingTop = state.top

        const commitDrag = () => {
            dragFrame = null
            const maxLeft = Math.max(window.innerWidth - card.offsetWidth, 0)
            const maxTop = Math.max(window.innerHeight - card.offsetHeight, 0)
            state.left = clamp(pendingLeft, -card.offsetWidth * 0.4, maxLeft)
            state.top = clamp(pendingTop, -card.offsetHeight * 0.4, maxTop)
            card.style.left = `${state.left}px`
            card.style.top = `${state.top}px`
        }

        const handlePointerMove = moveEvent => {
            if (!state.dragging) return

            pendingLeft = moveEvent.clientX - state.dragOffsetX
            pendingTop = moveEvent.clientY - state.dragOffsetY
            if (dragFrame === null) {
                dragFrame = requestAnimationFrame(commitDrag)
            }
        }

        const handlePointerUp = () => {
            state.dragging = false
            state.lastPosition = {left: state.left, top: state.top}
            card.classList.remove('dragging')
            header.classList.remove('dragging')
            if (dragFrame !== null) {
                cancelAnimationFrame(dragFrame)
                commitDrag()
            }
            document.removeEventListener('pointermove', handlePointerMove)
            document.removeEventListener('pointerup', handlePointerUp)
        }

        document.addEventListener('pointermove', handlePointerMove)
        document.addEventListener('pointerup', handlePointerUp)
    }

    // ✅ 从后端接口获取 messages
    async function fetchMessages() {
        try {
            const res = await fetch('/api/notes')
            const data = await res.json()
            console.log('✅ 已解析消息:', data)
            if (Array.isArray(data)) {
                data.forEach(msg => createCard(msg))
            } else {
                console.warn('⚠️ 返回格式不是数组:', data)
            }
        } catch (e) {
            console.error('❌ 获取消息失败:', e)
        }
    }

    function createCard(message) {
        const card = document.createElement('div')
        card.className = 'card'

        const color = randomFrom(colors)
        const angle = (Math.random() - 0.5) * 8
        const cardWidth = isMobile ? 180 : 220
        const cardHeight = isMobile ? 130 : 140
        const horizontalMargin = isMobile ? 12 : 16
        const verticalMargin = isMobile ? 12 : 20
        const left =
            horizontalMargin +
            Math.random() *
            Math.max(window.innerWidth - cardWidth - horizontalMargin * 2, 0)
        const top =
            verticalMargin +
            Math.random() *
            Math.max(window.innerHeight - cardHeight - verticalMargin * 2, 0)

        card.style.background = color
        card.style.left = `${left}px`
        card.style.top = `${top}px`
        card.style.zIndex = ++zIndexCursor

        card.innerHTML = `
					<div class="card-header">
						<div class="window-controls">
							<button class="control close" type="button" aria-label="关闭"></button>
							<button class="control minimize" type="button" aria-label="最小化"></button>
							<button class="control maximize" type="button" aria-label="最大化"></button>
						</div>
						<div class="card-title">温馨提示</div>
					</div>
					<div class="card-body">${message}</div>
				`

        const state = {
            angle,
            scale: isMobile ? 0.85 : 0.7,
            left,
            top,
            maximized: false,
            closing: false,
            lastPosition: {left, top}
        }

        cardStates.set(card, state)
        applyTransform(card, state)
        board.appendChild(card)

        state.width = card.offsetWidth
        state.height = card.offsetHeight

        requestAnimationFrame(() => {
            state.scale = 1
            applyTransform(card, state)
            card.style.opacity = '1'
        })

        setupCardInteractions(card)
    }

    // ✅ 启动时从接口加载
    fetchMessages()

    window.addEventListener('resize', () => {
        isMobile =
            window.matchMedia('(pointer: coarse)').matches ||
            window.innerWidth <= 768
        document.body.classList.toggle('is-mobile', isMobile)
        document.querySelectorAll('.card.maximized').forEach(card => {
            card.style.width = `${window.innerWidth}px`
            card.style.height = `${window.innerHeight}px`
        })
    })

    const noteInput = document.getElementById('note-input');
    const noteSubmit = document.getElementById('note-submit');

    async function sendNote() {
        const text = noteInput.value.trim();
        if (!text) return;

        try {
            const res = await fetch('/api/notes', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({content: text})
            });
            const result = await res.json();
            console.log('响应结果:', result);
            if (result.statusCode === 200) {
                createCard(text); // ✅ 立即显示便签
                noteInput.value = '';
            } else {
                alert(result.message);
                console.error('❌ 发送失败:', result.message);
            }
        } catch (e) {
            console.error('❌ 网络错误:', e);
        }
    }

    // 点击按钮或按回车都能添加
    noteSubmit.addEventListener('click', sendNote);
    noteInput.addEventListener('keydown', e => {
        if (e.key === 'Enter') sendNote();
    });
</script>
</body>
</html>
